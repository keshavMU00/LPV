# -*- coding: utf-8 -*-
"""Addition_Matrix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BLNyBCFkYtNda2QfgrUXA1-5kGK7xhOF
"""

!pip install pycuda

import numpy as np
import pycuda.autoinit
import pycuda.driver as cuda
from pycuda.compiler import SourceModule
import time

# CUDA kernel code
kernel_code = """
__global__ void vectorAdd(const float *A, const float *B, float *C, int N) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N) {
        C[idx] = A[idx] + B[idx];
    }
}

__global__ void matrixMul(const float *A, const float *B, float *C, int M, int N, int K) {
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < M && col < K) {
        float sum = 0.0f;
        for (int i = 0; i < N; i++) {
            sum += A[row * N + i] * B[i * K + col];
        }
        C[row * K + col] = sum;
    }
}
"""

def get_positive_int(prompt):
    while True:
        try:
            value = int(input(prompt))
            if value <= 0:
                print("Please enter a positive integer.")
                continue
            return value
        except ValueError:
            print("Invalid input. Please enter a positive integer.")

def get_float_array(prompt, size):
    print(f"{prompt} ({size} values):")
    while True:
        try:
            values = input("Enter values separated by spaces: ").strip().split()
            if len(values) != size:
                print(f"Please enter exactly {size} values.")
                continue
            return np.array([float(v) for v in values]).astype(np.float32)
        except ValueError:
            print("Invalid input. Please enter valid floating-point numbers.")

def get_matrix(prompt, rows, cols):
    print(f"{prompt} ({rows}x{cols} matrix, enter {rows} rows with {cols} values each):")
    matrix = []
    for i in range(rows):
        while True:
            try:
                row = input(f"Row {i+1}: ").strip().split()
                if len(row) != cols:
                    print(f"Please enter exactly {cols} values for row {i+1}.")
                    continue
                row_values = [float(v) for v in row]
                matrix.append(row_values)
                break
            except ValueError:
                print("Invalid input. Please enter valid floating-point numbers.")
    return np.array(matrix).astype(np.float32)

def main():
    # Get vector dimensions and values
    print("Enter dimensions for vector addition:")
    N = get_positive_int("Vector size (N): ")
    h_A_vec = get_float_array("Vector A", N)
    h_B_vec = get_float_array("Vector B", N)
    h_C_vec = np.zeros(N, dtype=np.float32)
    vector_size = N * np.dtype(np.float32).itemsize

    # Get matrix dimensions and values
    print("\nEnter dimensions for matrix multiplication (A: M x N, B: N x K, C: M x K):")
    M = get_positive_int("Rows of matrix A (M): ")
    N_mat = get_positive_int("Columns of matrix A / Rows of matrix B (N): ")
    K = get_positive_int("Columns of matrix B (K): ")

    h_A_mat = get_matrix("Matrix A", M, N_mat)
    h_B_mat = get_matrix("Matrix B", N_mat, K)
    h_C_mat = np.zeros((M, K), dtype=np.float32)

    # Allocate device memory
    d_A_vec = cuda.mem_alloc(vector_size)
    d_B_vec = cuda.mem_alloc(vector_size)
    d_C_vec = cuda.mem_alloc(vector_size)

    d_A_mat = cuda.mem_alloc(M * N_mat * np.dtype(np.float32).itemsize)
    d_B_mat = cuda.mem_alloc(N_mat * K * np.dtype(np.float32).itemsize)
    d_C_mat = cuda.mem_alloc(M * K * np.dtype(np.float32).itemsize)

    # Copy inputs to device
    cuda.memcpy_htod(d_A_vec, h_A_vec)
    cuda.memcpy_htod(d_B_vec, h_B_vec)
    cuda.memcpy_htod(d_A_mat, h_A_mat)
    cuda.memcpy_htod(d_B_mat, h_B_mat)

    # Compile and get kernel functions
    mod = SourceModule(kernel_code)
    vector_add = mod.get_function("vectorAdd")
    matrix_mul = mod.get_function("matrixMul")

    # Set up grid and block dimensions for vector addition
    block_size_vec = 256
    grid_size_vec = (N + block_size_vec - 1) // block_size_vec

    # Execute vector addition kernel
    start_time = time.time()
    vector_add(
        d_A_vec, d_B_vec, d_C_vec, np.int32(N),
        block=(block_size_vec, 1, 1),
        grid=(grid_size_vec, 1)
    )
    vector_time = time.time() - start_time

    # Set up grid and block dimensions for matrix multiplication
    block_size_mat = (16, 16, 1)
    grid_size_mat = ((K + block_size_mat[0] - 1) // block_size_mat[0],
                     (M + block_size_mat[1] - 1) // block_size_mat[1])

    # Execute matrix multiplication kernel
    start_time = time.time()
    matrix_mul(
        d_A_mat, d_B_mat, d_C_mat,
        np.int32(M), np.int32(N_mat), np.int32(K),
        block=block_size_mat,
        grid=grid_size_mat
    )
    matrix_time = time.time() - start_time

    # Copy results back to host
    cuda.memcpy_dtoh(h_C_vec, d_C_vec)
    cuda.memcpy_dtoh(h_C_mat, d_C_mat)

    # Print vector addition result
    print("\nVector addition result:")
    print(np.round(h_C_vec, 2))

    print(f"\nVector addition time: {vector_time:.6f} seconds")

    # Print matrix multiplication result
    print("\nMatrix multiplication result:")
    print(np.round(h_C_mat, 2))

    print(f"\nMatrix multiplication time: {matrix_time:.6f} seconds")

if __name__ == "__main__":
    # Install PyCUDA in Colab if needed
    try:
        import pycuda
    except ImportError:
        !pip install pycuda
        import pycuda

    main()